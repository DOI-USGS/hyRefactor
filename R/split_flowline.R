#' @title Split Flowlines
#' @description A wrapper for split_lines that works on nhdplus attributes
#' @param flines data.frame with COMID, toCOMID, LENGTHKM
#' and LINESTRING sf column in "meters" projection
#' @param max_length maximum segment length to return
#' @param events data.frame containing events as generated by nhdplusTools::get_flowline_index() 
#' @param para numeric how many threads to use in parallel computation
#' @param avoid vector of ids to avoid
#' @return All the flowlines with some split apart. COMIDs are returned as strings 
#' with a semantic part number appended. That is .1, .2, ... .10, .11, etc. are 
#' appended and must be treated as one would treat a semantic version. .1 is the 
#' most upstream and the sequence increases in the downstream direction.
#' @importFrom dplyr group_by ungroup filter select mutate lead n right_join
#' @seealso The \code{\link{refactor_nhdplus}} function implements a complete
#' workflow using `split_flowlines()`.
#' @export
#'
split_flowlines <- function(flines, max_length = NULL, 
                            events = NULL, para = 0, avoid = NA) {
  
  check_names(flines, "split_flowlines")
  
  flines <- st_rename(flines, "geom")
  
  split <- split_lines(flines, max_length, events, 
                       para = para, 
                       avoid = avoid)
  
  if (!is.null(split)) {
    
    split <- left_join(split, 
                       select(sf::st_set_geometry(flines, NULL), COMID, toCOMID, LevelPathI, Hydroseq, TotDASqKM), 
                       by = "COMID")
    
    split$part <- unlist(lapply(strsplit(split$split_fID, "\\."),
                                function(x) x[2]))
    
    split <- group_by(split, COMID)
    
    split <- mutate(split, part = (ifelse(is.na(part), 0, as.integer(part)) + 1))
    
    # Assume flowdir is with digitized for now -- need to check in prep code.
    split <- ungroup(mutate(split,
                            toCOMID = ifelse(part == max(part),
                                             as.character(toCOMID),
                                             paste(lead(COMID),
                                                   lead(part), sep = "."))))
    
    split <- mutate(split, COMID = paste(COMID, part, sep = "."),
                    LENGTHKM = sf::st_length(sf::st_geometry(split)) / 1000)
    
    split <- sf::st_as_sf(select(split, -part, -split_fID))
    
    attr(split$LENGTHKM, "units") <- NULL
    split[["LENGTHKM"]] <- as.numeric(split[["LENGTHKM"]])
    
    remove_comid <- unique(as.integer(split[["COMID"]]))
    
    not_split <- dplyr::filter(select(flines, .data$COMID, .data$toCOMID, 
                                      .data$LENGTHKM, .data$LevelPathI, 
                                      .data$Hydroseq, .data$TotDASqKM), !(.data$COMID %in% remove_comid))
    
    not_split <- dplyr::mutate(not_split, event_REACHCODE = "", event_REACH_meas = NA)
    
    flines <- rbind(not_split, split)
    
    # Rows with COMID like this need to be updated
    redirect_tocomid <- flines$COMID[which(grepl("\\.1$", flines$COMID))]
    
    old_tocomid <- gsub("\\.1$", "", redirect_tocomid)
    
    mutate(flines,
           toCOMID = ifelse(toCOMID %in% old_tocomid,
                            paste0(toCOMID, ".1"),
                            toCOMID))
    
  } else {
    flines %>%
      mutate(COMID = as.character(COMID),
             toCOMID = as.character(toCOMID),
             event_REACHCODE = "",
             event_REACH_meas = NA)
  }
}


check_split_data <- function(input_lines) {
  if(!"COMID" %in% names(input_lines)) stop("input lines must containt 'COMID' column.")
  if(attr(input_lines, "sf_column") != "geom") stop("sf_column must be 'geom'")
  if(!"sfc_LINESTRING" %in% class(st_geometry(input_lines))) stop("lines must be class LINESTRING")
  sf::st_crs(input_lines)
}

#' @title split lines
#' @description Splits lines longer than a given threshold into the
#' minimum number of pieces to all be under the given threshold.
#' @param input_lines data.frame of class sf with LINESTRING sfc column.
#' @param max_length maximum segment length to return
#' @param events data.frame containing events as generated by nhdplusTools::get_flowline_index() 
#' @param id name of ID column in data.frame
#' @param para how many cores to use
#' @param avoid vector of ids to avoid
#' @return only the split lines.
#' @importFrom dplyr group_by ungroup filter select mutate
#' @noRd
#'
split_lines <- function(input_lines, 
                        max_length, 
                        events = NULL, para = 0, 
                        avoid = NA, status = FALSE) {
  
  input_crs <- check_split_data(input_lines)
  
  # First split by event and number parts in a seperate column
  if(!is.null(events)) {
   
    already_split <- split_by_event(input_lines, events, input_crs)
    
    # Going into the next split, all too-long lines will have a part id of 0 or more
    # based on the split_fID_event from above.
    # split_fID_event is 0 for untouched too_long geometries
    # split_fID_event is 1 and event_REACHCODE is not "" for the top of a split geometry event splitting.
    # split_fID_event is >1 for any downstream split geometries from event splitting
    input_lines <- input_lines %>%
      dplyr::filter(!COMID %in% already_split$COMID) %>%
      dplyr::select(COMID) %>%
      dplyr::mutate(split_fID_event = 0,
                    event_REACHCODE = "", 
                    event_REACH_meas = NA) %>%
      rbind(already_split)
    
    # Doing this to conserve memory -- it's lumped into input_lines now but need the ids later.
    already_split <- already_split$COMID
    
  } else {
    
    input_lines <- dplyr::mutate(input_lines, 
                                 split_fID_event = 0, 
                                 event_REACHCODE = "", 
                                 event_REACH_meas = NA)
    
    already_split <- character(0)
  }
  
  input_lines <- add_length(input_lines)

  if(!is.null(max_length)) {
    
    if (max_length < 50) warning(paste("short max length detected,",
                                       "do you have your units right?"))
    
    # Given input that has potentially been split at events, find what's still too long.
    too_long <- select(input_lines, COMID, split_fID_event, geom_len, event_REACHCODE, event_REACH_meas) %>%
      filter(COMID %in% already_split | (geom_len >= max_length & !COMID %in% avoid))
  }
  
  # If anything is too long...
  if (nrow(too_long) != 0) {

    already_split <- split_by_length(too_long, max_length, para, input_crs)
    
  # If nothing is too long, but we DID split by event previously
  } else if(!is.null(nrow(already_split))) {
    
        # Add number of pieces and a sequence identifier.
    ids <- unique(already_split$COMID)
    ids <- data.frame(COMID = ids, 
                      fID = seq_len(length(ids)))
    
    ## TODO: Make sure this is still right! (test it)
    already_split <- already_split %>%
      left_join(ids, by = "COMID") %>%
      group_by(fID) %>%
      mutate(split_fID = ifelse(dplyr::row_number() == 1,
                                as.character(fID),
                                paste0(fID, ".", dplyr::row_number() - 1))) %>%
      select(COMID, split_fID, split_fID_event, event_REACHCODE, event_REACH_meas, -fID)
    
  } else {
    
    return(NULL)
    
  }
  
  if("split_fID_event" %in% names(already_split)) {
    already_split <- dplyr::select(already_split, -split_fID_event)
  }
  
  return(already_split)
}

new_line <- function(i, f, t, l) {
  lwgeom::st_linesubstring(x = sf::st_geometry(l)[i],
                           from = f,
                           to = t)[[1]]
}

# rescale REACH_meas to comid_meas

rf <- function(m, f, t) {
  if(any(!sapply(m, function(m, f, t) (m >= f & m <= t), f = f, t = t))) stop("m must be between f and t")
  
  100 * (m - f) / (t - f)
  
}

add_length <- function(input_lines) {
  
  input_lines$geom_len <- sf::st_length(sf::st_geometry(input_lines))
  attr(input_lines$geom_len, "units") <- NULL
  input_lines$geom_len <- as.numeric(input_lines$geom_len)
  
  input_lines
}

split_by_event <- function(input_lines, events, input_crs) {
  check_names(input_lines, "split_lines_event")
  
  # identify which flowlines need to be split so we can just iterate over those.
  to_split_ids <- sapply(seq_len(nrow(events)), 
                         function(x, events, input_lines) {
                           e <- events[x, ]
                           
                           # from is downstream -- 0 is the outlet
                           # to is upstream -- 100 is the inlet
                           dplyr::filter(input_lines, .data$REACHCODE == e$REACHCODE &
                                           .data$ToMeas > e$REACH_meas & 
                                           .data$FromMeas < e$REACH_meas)$COMID
                         }, events = events, input_lines = input_lines)
  
  # filter down so we could parallelize this without blowing out memory.
  to_split <- filter(input_lines, COMID %in% to_split_ids)
  
  # For each catchment to split, find all events that need to be enforced
  # split into parts and add a "parts" numbered from upstream (0 measure)
  # to downstream (100 measure).
  split_l <- lapply(seq_len(nrow(to_split)), 
                    function(x, to_split, events, crs) {
                      
                      l <- to_split[x, ]
                      
                      # only work on events in the interval of the current flowline
                      e <- dplyr::filter(events, 
                                         .data$REACHCODE %in% l$REACHCODE &
                                         .data$REACH_meas < l$ToMeas &
                                           .data$REACH_meas > l$FromMeas)
                      
                      # arrange in upstream downstream order (greater measures are upstream)
                      # from is downstream -- 0 is the outlet
                      # to is upstream -- 100 is the inlet
                      # This is important so things are in the right order for splitting
                      # and available in that order to be joined in back in.
                      e <- dplyr::arrange(e, desc(REACH_meas))
                      
                      # This function is defined elsewhere and tested.
                      comid_meas <- rf(e$REACH_meas, l$FromMeas, l$ToMeas)
                      
                      split_points <- data.frame(COMID = l$COMID,
                                                 split_fID_event = seq_len(nrow(e) + 1),
                                                 start = c(0, 100 - comid_meas) / 100, 
                                                 end = c(100 - comid_meas, 100) / 100,
                                                 event_REACHCODE = c(e$REACHCODE, ""),
                                                 event_REACH_meas = c(e$REACH_meas, NA))
                      
                      sl<- lapply(seq_len(nrow(split_points)),
                                  function(x, l, s) {
                                    # Always 1 feature as input so i is degenerate here.
                                    new_line(i = 1,
                                             f = s$start[x],
                                             t = s$end[x], 
                                             l = l)
                                  }, l = l, s = split_points)
                      
                      sl <- sf::st_sf(split_points[c("COMID", "split_fID_event", "event_REACHCODE", "event_REACH_meas")],
                                      geom = sf::st_sfc(sl,
                                                                  crs = crs))
                      
                    }, to_split = to_split, events = events, crs = input_crs)
  
  split_l <- do.call(rbind, split_l)
  
  split_l
}

split_by_length <- function(too_long, max_length, para, input_crs) {
  
  # pieces is the number of pieces we need to break each too long feature into.
  # fID is an identifier for a given geometry which may have already been split!
  too_long <- too_long %>%
    mutate(pieces = ceiling(geom_len / max_length),
           fID = seq_len(nrow(too_long))) %>%
    select(-geom_len)
  
  # rep here is done by row of too_long so we get a row with the correct fID 
  # for each part we expect in the output.
  split_points <-
    sf::st_set_geometry(too_long, NULL)[rep(seq_len(nrow(too_long)),
                                            too_long[["pieces"]]), ] %>%
    select(-pieces)
  
  event_test <- c(diff(split_points$split_fID_event) == 1, FALSE)
  
  split_points <- mutate(split_points, 
                         event_REACHCODE = ifelse(event_test, event_REACHCODE, ""),
                         event_REACH_meas = ifelse(event_test, event_REACH_meas, NA))
  
  # Assign featureIDs to the output. start and end are decimal % along catchment
  split_points <- split_points %>%
    group_by(fID) %>%
    mutate(split_fID = ifelse(dplyr::row_number() == 1,
                              as.character(fID),
                              paste0(fID, ".", dplyr::row_number() - 1))) %>%
    mutate(piece = 1:n()) %>%
    mutate(start = (piece - 1) / n(),
           end = piece / n()) %>%
    ungroup()
  
  cl <- NULL
  if(para > 1) {
    cl <- parallel::makeCluster(rep("localhost", para),
                                type = "SOCK")
  }
  
  pbapply::pboptions("none")
  
  split_l <- pbapply::pblapply(seq_len(nrow(split_points)),
                              FUN = function(x, s, too_long) {
                                new_line(i = which(too_long$fID == s$fID[x]),
                                         f = split_points$start[x],
                                         t = split_points$end[x], 
                                         l = too_long)
                              }, cl = cl, s = split_points, too_long = too_long)
  
  rm(too_long)
  
  split_l <- sf::st_sf(split_points[c("COMID", "split_fID", "event_REACHCODE", "event_REACH_meas")],
                       geom = sf::st_sfc(split_l, crs = input_crs))
  
  split_l
}
