#' Aggregate Catchments
#' @description Aggregates catchments according to a set of outlet catchments. 
#' Network aggregation is completed using: See \code{\link[nhdplusTools]{aggregate_network}}.
#' @param flowpath sf data.frame Flowpaths as generated by `refactor_nhdplus`
#' @param divide sf data.frame Reconciled catchment divides as generated by
#' `reconcile_catchment_divides`
#' @param outlets data.frame with "ID" and "type" columns. "ID" must be identifiers from
#' flowpath and divide data.frames. "type" should be "outlet", or "terminal".
#' "outlet" will include the specified ID.
#' "terminal" will be treated as a terminal node with nothing downstream.
#' @param zero_order list of vectors containing IDs to be aggregated into 0-order catchments.
#' @param coastal_cats sf data.frame with coastal catchments to be used with zero order.
#' @param da_thresh numeric See \code{\link[nhdplusTools]{aggregate_network}}
#' @param only_larger boolean See \code{\link[nhdplusTools]{aggregate_network}}
#' @details See \code{\link[nhdplusTools]{aggregate_network}}
#'
#' @export
#' @importFrom sf st_transform st_cast st_union st_geometry st_crs st_multipolygon
#' @importFrom dplyr filter left_join bind_rows
#' @importFrom nhdplusTools aggregate_network
#' @examples
#' source(system.file("extdata", "walker_data.R", package = "hyRefactor"))
#' outlets <- data.frame(ID = c(31, 3, 5, 1, 45, 92),
#'                       type = c("outlet", "outlet", "outlet", "terminal", "outlet", "outlet"),
#'                       stringsAsFactors = FALSE)
#' aggregated <- aggregate_catchments(walker_fline_rec, walker_catchment_rec, outlets)
#' plot(aggregated$cat_sets$geom, lwd = 3, border = "red")
#' plot(walker_catchment_rec$geom, lwd = 1.5, border = "green", col = NA, add = TRUE)
#' plot(walker_catchment$geom, lwd = 1, add = TRUE)
#' plot(walker_flowline$geom, lwd = .7, col = "blue", add = TRUE)
#'
#' plot(aggregated$cat_sets$geom, lwd = 3, border = "black")
#' plot(aggregated$fline_sets$geom, lwd = 3, col = "red", add = TRUE)
#' plot(walker_flowline$geom, lwd = .7, col = "blue", add = TRUE)
#'

aggregate_catchments <- function(flowpath, divide, outlets, zero_order = NULL,
                                 coastal_cats = NULL,
                                 da_thresh = NA, only_larger = FALSE, 
                                 post_mortem_file = NA) {
  
  if(!is.null(zero_order)) {
    
    if(is.null(coastal_cats)) stop("must supply coastal_cats with zero order")
    
    if(st_crs(coastal_cats) != st_crs(divide)) st_transform(coastal_cats, st_crs(divide))
    
    zero_flowpath <- filter(flowpath, member_COMID %in% do.call(c, zero_order))
  
    flowpath <- filter(flowpath, !ID %in% zero_flowpath$ID)
    
    coastal <- lapply(zero_order, function(x, coastal_cats, divide) {
      
      zero_cats <- filter(coastal_cats, FEATUREID %in% x)
      
      zero_div <- filter(divide, member_COMID %in% as.character(x))
      
      st_union(c(st_geometry(zero_cats), st_geometry(zero_div)))[[1]]
    }, coastal_cats = coastal_cats, divide = divide)
    
    coastal <- st_sfc(coastal, crs = st_crs(divide))
    
    coastal <- st_sf(ID = names(coastal), geom = coastal)
  } else {
    coastal <- NULL
  }
  
  if(any(remove_head_div <- !flowpath$ID %in% flowpath$toID & 
         !flowpath$ID %in% divide$ID)) {
    remove_fpaths <- filter(flowpath, remove_head_div)
    message(paste("removing", nrow(remove_fpaths), 
                  "headwater/diversion flowlines without catchments."))
    flowpath <- filter(flowpath, !ID %in% remove_fpaths$ID)
  }

  agg_network <- aggregate_network(flowpath, outlets, da_thresh, only_larger, post_mortem_file)

  for (cat in seq_len(nrow(agg_network$cat_sets))) {
    
    abort_code <- tryCatch(
      {
        
        sub <- filter(divide, ID %in% unlist(agg_network$cat_sets$set[cat]))
        
        geom <- try(st_union(st_geometry(sub)), 
                    silent = TRUE)
        
        if(inherits(geom, "try-error")) {
          geom <- try(st_union(st_make_valid(st_geometry(sub))))
        }
        
        if(length(geom) > 0) {
          agg_network$cat_sets$geom[[cat]] <- geom[[1]]
        } else {
          agg_network$cat_sets$geom[[cat]] <- st_multipolygon()
        }
        
        abort_code <- ""
      }, error = function(e) e
    )
    
    if(abort_code != "")  {
      if(!is.na(post_mortem_file)) {
        save(list = ls(), file = post_mortem_file)
        stop(paste("error getting geometry type or with union, post mortem file:", post_mortem_file))
      } else {
        stop(paste("error getting geometry type or with union for line merge:", abort_code))
      }
    }

  }

  agg_network$cat_sets$geom <- st_cast(st_sfc(agg_network$cat_sets$geom, crs = st_crs(divide)), "MULTIPOLYGON")

  agg_network$cat_sets <- st_sf(agg_network$cat_sets)

  return(c(agg_network, list(coastal_sets = coastal)))
}
